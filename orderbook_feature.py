# -*- coding: utf-8 -*-
"""orderbook-feature.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13xIzMV-LZoIdEcJtmR2PlMn80QJbLn87
"""

import time
import requests
import pandas as pd
import csv
import math

import os
from datetime import datetime
from pytz import timezone
# colab 사용 시, data 저장하기 위해 driver mounting
from google.colab import drive

drive.mount('/content/drive')

# working directory
print(os.getcwd())

file_path = "/content/drive/MyDrive/jh_assignment/data"  # csv 파일이 있는 디렉토리
columns_feature = ["timestamp", "mid_price", "book-imbalance"]  # csv 파일 컬럼명
# file_name = "2023-11-10-exchange-market-orderbook.csv"  # csv 파일 이름

if (not os.path.isdir(file_path)):
    os.mkdir(file_path)

"""#### Calculate mid price"""

# Feature : calculation midprice using orderbook

"""
  mid price 를 계산하는 함수
"""
def cal_mid_price(gr_bid_level, gr_ask_level):
    """
    gr_bid_level : all bid level
    gr_ask_level : all ask level
    """
    level = 5  # not using

    # mid_price 계산
    if len(gr_bid_level) > 0 and len(gr_ask_level) > 0:
        bid_top_price, bid_top_level_qty = gr_bid_level.iloc[0].price, gr_bid_level.iloc[0].quantity
        ask_top_price, ask_top_level_qty = gr_ask_level.iloc[0].price, gr_ask_level.iloc[0].quantity
        mid_price = (bid_top_price + ask_top_price) * 0.5

        return (mid_price, bid_top_price, ask_top_price, bid_top_level_qty, ask_top_level_qty)

    else:
        print('Error: serious cal_mid_price')
        return (-1, -1, -2, -1, -1)

"""#### Calculate book imbalance"""

# Feature : calculating 'bookI' using orderbook
# book imbalance


"""
  book imbalance 를 계산하는 함수
"""
def live_cal_book_i_v1(param, gr_bid_level, gr_ask_level, mid):
    """
    param = [ratio, level, interval]
    gr_bid_level: all bid level
    gr_ask_level: all ask level
    mid: midprice
    """
    # 초기값 세팅
    mid_price = mid
    ratio, level, interval = param

    # 모든 bid, and level에 대해 Querytity, Price 계산
    quant_v_bid = gr_bid_level.quantity**ratio
    price_v_bid = gr_bid_level.price * quant_v_bid
    quant_v_ask = gr_ask_level.quantity**ratio
    price_v_ask = gr_ask_level.price * quant_v_ask

    ask_qty, ask_px = quant_v_ask.values.sum(), price_v_ask.values.sum()
    bid_qty, bid_px = quant_v_bid.values.sum(), price_v_bid.values.sum()
    bid_ask_spread = interval

    # book_price 계산
    book_price = 0 #because of warning, divisible by 0
    if bid_qty > 0 and ask_qty > 0:
        book_price = (((ask_qty*bid_px)/bid_qty) + ((bid_qty*ask_px)/ask_qty)) / (bid_qty+ask_qty)

    # book imbalance 계산
    book_imbalance = (book_price - mid_price) / bid_ask_spread  # indicator_value = (book_price - mid_price)

    return book_imbalance

"""#### Extract data from csv file"""

"""
  orderbook csv 데이터를 dataframe으로 반환하는 함수
"""
def get_orderbook_df(file_name):
    print('loading... %s' % file_name)

    return pd.read_csv(file_name).apply(pd.to_numeric,errors='ignore')  # df

"""#### orderbook_feature method"""

import itertools

param = [0.2, 5, 1]  # ratio, level, interval

"""
  orderbook 데이터를 feature 계산하는 함수
"""
def orderbook_feature(file_name):
    # csv 파일 dataframe으로 불러오기
    df = get_orderbook_df(f"{file_path}/{file_name}")

    # timestamp로 그룹핑
    df_groupby_timestamp = df.groupby(['timestamp'])

    # get timestamp value (book imbalance 값을 저장하기 위한 파일명으로 사용)
    file_timestamp = df.iloc[0]['timestamp']

    # timestamp, mid_price, book_imbalance 값을 담을 배열 초기화
    _timestamp = []
    _mid_price = []
    _book_imbalance = []

    # timestamp 별 mid_price, book_imbalance 계산
    for gr_o in zip(df_groupby_timestamp):  # gr_o : ((timestamp, dataframe),)
        if gr_o is None:
            print('Warning: group is empty')
            continue

        timestamp = gr_o[0][0]
        gr_o = gr_o[0][1]

        gr_bid_level, gr_ask_level = gr_o[(gr_o.type == 0)], gr_o[(gr_o.type == 1)]

        # mid_price, book_imbalance 계산하는 함수 호출
        mid_price, bid, ask, bid_qty, ask_qty = cal_mid_price(gr_bid_level, gr_ask_level)
        book_imbalance = live_cal_book_i_v1(param, gr_bid_level, gr_ask_level, mid_price)

        # 배열에 각각의 값 추가
        _timestamp.append(timestamp)
        _mid_price.append(mid_price)
        _book_imbalance.append(book_imbalance)

    # 맨 앞 3개의 값만 출력
    print(_timestamp[0], _timestamp[1], _timestamp[3])
    print(_mid_price[0], _mid_price[1], _mid_price[3])
    print(_book_imbalance[0], _book_imbalance[1], _book_imbalance[3])

    result_df = pd.DataFrame([_timestamp, _mid_price, _book_imbalance]).transpose()
    result_df.columns = columns_feature

    return file_timestamp, result_df

# 2023-11-13-exchange-market-orderbook.csv 파일 계산
file_timestamp, result_df = orderbook_feature(file_name = "2023-11-13-exchange-market-orderbook.csv")  # csv 파일 이름

print(result_df)

"""
  orderbook feature 데이터를 csv 파일로 저장하는 함수
"""
def save_data_to_csv(timestamp, df):

    # 파일 이름 생성 (YYYY-MM-DD만 사용)
    file_name = f"{timestamp.split(' ')[0]}-exchange-market-feature.csv"

    # orderbook 데이터 csv에 파일에 저장
    # if -> 파일이 없는 경우, 새로운 파일에 저장
    if (not os.path.exists(f"{file_path}/{file_name}")):
      df.to_csv(f"{file_path}/{file_name}", columns=columns_feature, sep=',', index=False)
    # else -> 이미 파일이 있는 경우, 데이터 추가
    else:
      df.to_csv(f"{file_path}/{file_name}", header=False ,sep=',', index=False, mode='a')


save_data_to_csv(file_timestamp, result_df)